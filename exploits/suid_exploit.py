import os
import json
import subprocess
from rich.console import Console
console = Console()

# Get the absolute path to the data directory
GTFO_DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "data")
GTFO_DATA_DIR = os.path.abspath(GTFO_DATA_DIR)

SUID_REPORT_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "exploit_suggestions.txt")


def check_and_update_data():
    """Interactive prompt to update GTFOBins data with auto-dependency install"""
    from rich.prompt import Prompt
    import subprocess
    from pathlib import Path
    import sys

    def install_deps():
        """Install yq and jq if missing"""
        try:
            console.print("[yellow]Checking/installing dependencies...[/yellow]")
            deps = {
                'yq': 'python-yq' if os.name == 'nt' else 'yq',
                'jq': 'jq'
            }
            
            for cmd, pkg in deps.items():
                if not subprocess.run(['which', cmd], capture_output=True).returncode == 0:
                    console.print(f"[yellow]Installing {cmd}...[/yellow]")
                    if os.name == 'nt':  # Windows
                        subprocess.run(['pip', 'install', pkg], check=True)
                    elif sys.platform == 'darwin':  # macOS
                        subprocess.run(['brew', 'install', pkg], check=True)
                    else:  # Linux
                        subprocess.run(['sudo', 'apt-get', 'install', '-y', pkg], check=True)
        except subprocess.CalledProcessError as e:
            console.print(f"[red]Failed to install dependencies: {e}[/red]")
            return False
        return True

    # Check dependencies first
    if not install_deps():
        return False

    # Check if data directory exists and has files
    data_exists = os.path.exists(GTFO_DATA_DIR) and any(
        f.endswith('.json') for f in os.listdir(GTFO_DATA_DIR))

    if not data_exists:
        console.print("[bold red]No GTFOBins data found![/bold red]")
        if Prompt.ask("[yellow]Would you like to download it now?[/yellow]", 
                     choices=['y', 'n']) == 'y':
            try:
                updater_path = Path(__file__).parent / "update_gtfobins.sh"
                subprocess.run(["chmod", "+x", str(updater_path)], check=True)
                subprocess.run([str(updater_path)], check=True)
                return True
            except subprocess.CalledProcessError as e:
                console.print(f"[red]Update failed: {e}[/red]")
                return False
        return False

    # Check if data is older than 30 days
    try:
        newest_file = max(
            os.path.getmtime(os.path.join(GTFO_DATA_DIR, f)) 
            for f in os.listdir(GTFO_DATA_DIR) 
            if f.endswith('.json'))
        
        from time import time
        if (time() - newest_file) > (30 * 24 * 3600):  # 30 days
            console.print("[yellow]Your GTFOBins data is older than 30 days[/yellow]")
            if Prompt.ask("[yellow]Would you like to update it now?[/yellow]", 
                         choices=['y', 'n']) == 'y':
                try:
                    updater_path = Path(__file__).parent / "update_gtfobins.sh"
                    subprocess.run(["chmod", "+x", str(updater_path)], check=True)
                    subprocess.run([str(updater_path)], check=True)
                    return True
                except subprocess.CalledProcessError as e:
                    console.print(f"[red]Update failed: {e}[/red]")
                    return False
    except Exception as e:
        console.print(f"[yellow]Warning: Couldn't check data age: {e}[/yellow]")
    
    return True

def load_gtfo_data(binary):
    """Load GTFOBins data for a specific binary"""
    try:
        binary_name = os.path.basename(binary)
        json_path = os.path.join(GTFO_DATA_DIR, f"{binary_name}.json")

        if os.path.exists(json_path):
            with open(json_path, 'r') as f:
                return json.load(f)
        return None
    except Exception as e:
        console.print(f"Error loading GTFOBins data: {str(e)}", "error")
        return None


def save_suid_exploits(binary, functions):
    """Save formatted SUID exploit suggestions to file"""
    try:
        with open(SUID_REPORT_FILE, 'a') as f:
            f.write(f"\n=== Exploits for {binary} ===\n")

            if isinstance(functions, dict):
                for func_type, entries in functions.items():
                    if not isinstance(entries, list):
                        continue
                    f.write(f"\n---------- [ {func_type.upper()} ] ----------\n")
                    for idx, entry in enumerate(entries):
                        if 'description' in entry:
                            f.write(f"# {entry['description'].strip()}\n")
                        f.write(entry['code'].strip() + "\n")
                        if idx < len(entries) - 1:
                            f.write("\n" + " - " * 10 + "\n")

            elif isinstance(functions, list):  # fallback for flat format
                f.write(f"\n---------- [ EXPLOIT ] ----------\n")
                for idx, entry in enumerate(functions):
                    if 'description' in entry:
                        f.write(f"# {entry['description'].strip()}\n")
                    f.write(entry['code'].strip() + "\n")
                    if idx < len(functions) - 1:
                        f.write("\n" + " - " * 10 + "\n")

            return True
    except Exception as e:
        console.print(f"Error saving exploits: {str(e)}", "error")
        return False


def exploit_suid(binary):
    """Check SUID binary for potential exploits"""
    if not binary or not os.path.exists(binary):
        return (False, "")

    try:
        st = os.stat(binary)
        if not os.access(binary, os.X_OK) or not (st.st_mode & 0o4000):
            return (False, "")
    except OSError:
        return (False, "")

    findings = []
    is_exploitable = False

    # Check GTFOBins data
    gtfo_data = load_gtfo_data(binary)
    if gtfo_data and 'functions' in gtfo_data:
        if save_suid_exploits(binary, gtfo_data['functions']):
            findings.append(" [GTFOBins]")
            is_exploitable = True

    # Generic checks
    try:
        result = subprocess.run(['strings', binary],
                                capture_output=True,
                                text=True)
        if 'execve' in result.stdout.lower():
            findings.append(" [!] Contains execve")
            is_exploitable = True

        if os.access(binary, os.W_OK):
            findings.append(" [!] Writable")
            is_exploitable = True
    except Exception:
        pass

    return (is_exploitable, "".join(findings))
