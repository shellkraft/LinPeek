import os
import json
import subprocess
from rich.console import Console
console = Console()

GTFO_DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "data")
GTFO_DATA_DIR = os.path.abspath(GTFO_DATA_DIR)
SUID_REPORT_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), "exploit_suggestions.txt")

def check_and_update_data():
    """Simplified version with clean output"""
    from rich.progress import Progress, SpinnerColumn, TextColumn
    from rich.prompt import Prompt
    import subprocess
    import os

    def run_update():
        """Run updater script and parse output"""
        updater = os.path.join(os.path.dirname(__file__), "update_gtfobins.sh")
        
        with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), transient=True) as progress:
            task = progress.add_task("Updating GTFOBins", start=True)

            
            # Run in quiet mode and capture summary
            result = subprocess.run(
                [updater, "--quiet"],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                progress.stop()
                console.print("\n[red]Update failed![/red]")
                return False
            
            # Parse machine-readable output
            summary = {
                line.split('=')[0]: line.split('=')[1] 
                for line in result.stdout.splitlines() 
                if '=' in line
            }
            
            console.print("\n[green]âœ“ Update successful![/green]")
            console.print(f"[dim]Found {summary.get('BIN_COUNT', '?')} binaries[/dim]")
            console.print(f"[dim]Saved in: {summary.get('DATA_PATH', '?')}[/dim]")
            return True

    if not os.path.exists(GTFO_DATA_DIR):
        console.print("[red]No GTFOBins data found![/red]")
        if Prompt.ask("[yellow]Download now?[/yellow]", choices=['y', 'n']) == 'y':
            return run_update()
    return True


def load_gtfo_data(binary):
    """Load GTFOBins data for a specific binary"""
    try:
        binary_name = os.path.basename(binary)
        json_path = os.path.join(GTFO_DATA_DIR, f"{binary_name}.json")

        if os.path.exists(json_path):
            with open(json_path, 'r') as f:
                return json.load(f)
        return None
    except Exception as e:
        console.print(f"Error loading GTFOBins data: {str(e)}", "error")
        return None


def save_suid_exploits(binary, functions):
    """Save formatted SUID exploit suggestions to file"""
    try:
        with open(SUID_REPORT_FILE, 'a') as f:
            f.write(f"\n=== Exploits for {binary} ===\n")

            if isinstance(functions, dict):
                for func_type, entries in functions.items():
                    if not isinstance(entries, list):
                        continue
                    f.write(f"\n---------- [ {func_type.upper()} ] ----------\n")
                    for idx, entry in enumerate(entries):
                        if 'description' in entry:
                            f.write(f"# {entry['description'].strip()}\n")
                        f.write(entry['code'].strip() + "\n")
                        if idx < len(entries) - 1:
                            f.write("\n" + " - " * 10 + "\n")

            elif isinstance(functions, list):  # fallback for flat format
                f.write(f"\n---------- [ EXPLOIT ] ----------\n")
                for idx, entry in enumerate(functions):
                    if 'description' in entry:
                        f.write(f"# {entry['description'].strip()}\n")
                    f.write(entry['code'].strip() + "\n")
                    if idx < len(functions) - 1:
                        f.write("\n" + " - " * 10 + "\n")

            return True
    except Exception as e:
        console.print(f"Error saving exploits: {str(e)}", "error")
        return False


def exploit_suid(binary):
    """Check SUID binary for potential exploits"""
    if not binary or not os.path.exists(binary):
        return (False, "")

    try:
        st = os.stat(binary)
        if not os.access(binary, os.X_OK) or not (st.st_mode & 0o4000):
            return (False, "")
    except OSError:
        return (False, "")

    findings = []
    is_exploitable = False

    # Check GTFOBins data
    gtfo_data = load_gtfo_data(binary)
    if gtfo_data and 'functions' in gtfo_data:
        if save_suid_exploits(binary, gtfo_data['functions']):
            findings.append(" [GTFOBins]")
            is_exploitable = True

    # Generic checks
    try:
        result = subprocess.run(['strings', binary],
                                capture_output=True,
                                text=True)
        if 'execve' in result.stdout.lower():
            findings.append(" [!] Contains execve")
            is_exploitable = True

        if os.access(binary, os.W_OK):
            findings.append(" [!] Writable")
            is_exploitable = True
    except Exception:
        pass

    return (is_exploitable, "".join(findings))
